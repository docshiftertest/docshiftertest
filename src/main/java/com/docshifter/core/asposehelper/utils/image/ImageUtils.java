package com.docshifter.core.asposehelper.utils.image;

import com.aspose.pdf.PageSize;
import com.aspose.pdf.Rectangle;
import com.aspose.words.ImageSize;
import com.aspose.words.PaperSize;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.imaging.ImageReadException;
import org.apache.commons.imaging.Imaging;
import org.apache.commons.imaging.common.bytesource.ByteSource;
import org.apache.commons.imaging.common.bytesource.ByteSourceFile;
import org.apache.commons.imaging.formats.jpeg.JpegImageParser;
import org.apache.commons.imaging.formats.jpeg.segments.UnknownSegment;
import org.apache.commons.lang.StringUtils;
import javax.imageio.IIOException;
import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import java.awt.*;
import java.awt.color.ColorSpace;
import java.awt.color.ICC_ColorSpace;
import java.awt.color.ICC_Profile;
import java.awt.image.BufferedImage;
import java.awt.image.ColorConvertOp;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.Iterator;
import java.util.List;

@Log4j2
public class ImageUtils {

	public static String DS_WHITE_LOGO_FILE_LOCATION = "/logos/logo-white-background.png";
	private static final String DS_LOGO_DATA = "89504E470D0A1A0A0000000D494844520000012C000000510802000000E7D40C8900000006624B474400FF00FF00FFA0BDA793000000097048597300000B1300000B1301009A9C180000000774494D4507E5031E151718713907B6000020004944415478DAED9D77781CD775E8CFBD53B6F745EF004182551429165122D5A862899265468E6C4BB664C779F99C3CC78EFDC54E9CD85F5EF29EA4B8A5D8CF794EE2224B6E8A12154BB62CD9A2A846B180BD810520DA62B1D85D6CDF9D76EFFB637681D98A01084A3139E79B8F1F309C19CCDCB9BF7BCE3DE7DC3388520A861862C87B2778D1AF282854500CB00D3144AFB08B7BB9A444BE79300C009F5BE77770D8685F430C7957214C4AE4ABFDE11F9D8A01804CE10BEB0D0E0D31E45D847086408950005051343834C49039052D8A63262192BFEF0F3F793A4FA02A1C460FF6B9BFB8DEEFE40D0E0D31A4AA2C021E49897CED602981002011FAE4E9D8D70E869312311ADA10432E95268C09CA6307C23F3D132F21D0D0878618F26E68C284481E3B10FE49750267F4E1DFF71BFAD010432ACBC21D33D19CF2C881A9FF389B90C91CBA54E51000FEE21AC34F6388218B648E4673CADFED9BFACFF37313A8B54B7776671EEC1D6CB435B8CC5D66CECB62B3F1020C3164211086B3CADFED0B3D3398D44FA02A0C9237FB5F7B5FF32F3C268BCBD2D1E4B8A6C1718DCBDCC918341A6240A85F2633F2DFEC0DBD7821355F026738DCE87BE3B6A667EC6C0A2130318E3AFBCA0ECF6D8D8E4D26D6FD9E37475A223141D1EE719B189B61421BF2DF07C25056FECA9ED00B1792E4225CAA18914DBEDDEF6B7EDAC26411020494C59CCFDAD7EDBBA7C57503C7D8DFC3E678F67CE2D1FEB076CF5FAEF7DFDBE3BC8C7B00A1D2F1C9A7E3B9B1993D26D6B9A6F14366D665E0F1EEC83C1C331369F9CBEF845E1ABE2802018050BC2FB295227C7BE37FDAD914202413692A7D2C9A393D32FD4A5FFD0375F6750831EF8D2694C9784A2CD97379F7004295A1E93783A9A3337B6C7CDDF2BAF71B10FEB783703223FFD59EC9974752643116482894DD37753D067267F353262C00428452002998DC17CB9E59E2DFD9E3BFEFBDB14E29002DDB73B90B0544289AFD55F3F362894C72092120291987A9D1C27991EED818A14A5A9C8AE586E3B9D1586E8452C5656E5DD5701F46DC9505E1445AFECBB7277F33BA3804AAEF99523A94DA14175FF79B87310595438C2027C74E4E3E3E9D1D58DDF429A7B9FBBDE89257DC3AAC929167D19F3F92397B60FCFBA1F40959C9D9F8FA25BE5B5735DCC733B639EDE4507AE0F4D40B13C9436929AC90BC85D2685FB3A2FE0357168497824044149F8DAF77B20088522008B41C12AA04E26F65C48935CDFFB3DEB111017EEF3AE415A10A292D1A791677144A0863BB871E0B67CEA8BFC672C307038F4B24B3A1E59335404A899307034F9E8FBE9693E333FE8B19BD7D99B53F7E4F08F458B83A878DC10828A500940251BB022042F31CC4B283FDA38F05136F5178776765B478BB6234E1257AEE33E19766089C517167C32F278440B553A6D2675E3EF7BF4E847E9195E397F4DE7E07200C65179F404C953ABBA9C165C71801504034DF092A7198164387C6BE114CEC79F738A405BD30BB5D011052201469B7C5BAB242C460EA58F9FE9C3C3D9DBD508DC05D435F9D481E279494BE0A5AAAB42F7308D312F9E6C1C822EB40AA782D9CCF61C51815EC9E7C93D6E0F048E09F62C543E9EFA84EF81DD2848B25082116992A763C06F3956CD7E0AE0BDF08A5CF547C1118710C36573CF1329C134A843E7E2AF6D333F1C5D68166AFDD82112A9980510054F8A9647E0800C9DCD8A1F1AF6FEAF85B1BDFFC6E74487AE5CD092F99630623AEDDBD652CB18FD0E21408739BCFB2A4546D52E9D0C4CF2793674A667D0CE2FCB6251DEE8D8DF63E9E71F08CF532E3B03284BB4653DF3E1291160D414054F1DB4C3EBB05CD1208082800A11421444B384414B086C368FAF489E0BFAD6BFD028B2DEF028570A50945F4928528BABD378D25F60D4FCFCEEDCDAC6B6DD38336BEAE74FA931A1808FF96144F3DAC9C677DF34796D7DD6EA914B7A440A6334322496B3A15F65A7BB84BDF4F2E2D84A349E9EB07A6E239191002B418EF83524408CF20547235543047CB380404A4C021020044C662BBBCD6953DFE9D97D6594ACB9C8357449CF0123EA599756DEDF8F346FBEA91F83B84C87653C332FF9D4D8EAB4B0E23543916FA655A4A80460DDA38EF2DDD9FEFF25C5BEDA52B447C7BF4DB93A9E3337B78C6FABEA55FF35B97FE0E432811FAAF47A74E463200388FC4C57388400134118D2300A7CD5AA2096738ADC62100251464229E09FDACDEBEDE69EEBAD45E8A2B4B0B021028D23E64B199B4709E358D1F5E59FF7B1408461CAE940E9512A7461387699129CBAC6BFE600D02559189242A82B64B9798BEBF7B8E99C3A1CC7F9D892984524A8052B438DE28841856C65C201A4FA433E57A876AAC20AD9F8602109A77A1120A2931702EFC34A192E19AB91443CFA5763F329867B1195749488C6647536258DBE87E6BCF8ABA3BE6347C2E83B755A40925853E713C12C94A08210A00401020D551A25F1FDA38DCEDE4FB3C7C9FD7A42EE125004371F1CCB430104E87620928E843546CFC211DFA7034B6ABDD7387DFB67AC10F4C28080A890B8A4229879183674C4CDE597B91AA5022342BD3A4A8008083672C2CE2F0C51A1184424254D21251EB299B1864E3B0936716766185888292501505872D26D659981520AD2FA4F8672ACAE99C92CA4831854826D66E619D66D6C12EB66B242E4C48A4286BB7DDB5DECA79F43491D677A1509216A3496EB2D42A669C1CA377A228939CA8A444259D93E366D6C533369EB1EB5FFE4AA852A22A4AF43F05A2260021C00CE6D91235F8F28518142FAC407987250534C798546F61B7B7DB76F63857784DE51D4550682025ED1E893D3B10896491D96251B51FA5488D16EAE1302BC50623CF7BAD7DF3CD5A2214C653E2BE40EAADF1D4F99830959544855A385C6F61FBBC96ADAD8EB50DD6461BB7808C99B4444E4485FD9399BDC1EC5456890A0A00F8CC4CBD85DDD868DED2685BE6E12DECBCE7B1D19CB23798F9ED58EA44448C0A8AA85000E019E43531CB3CFC4DADB62D4DD63A0BABB34B4532E7C712FB83A9634961427DFD4B7CB76E6AFDA31ADED19C9C0A244F9E8DBE35911AC8CAD3829C22546119B399B13B4D8D9DEE6B7A3C9BBC963606CD7D0F67232F079347B43D7275E37D4E53ABF6987066B8243E4901C612C7CAD429576F5B52F247B5A386A488AF0E7D9D29EB1E5BDAFFC752DFF6B93A8914CD5E188BEF1F4BEC4F0A0199E44425C333560E5BEDA6C656E78636D7268FA57DCEBE3712DF7364E2A7DA3D57357DB8D37DBD4C72D3D90B93E913E1F440520812AA5839EF968ECFB09A57457F72221CCB4A08615AFC3E50DE6149AA716862D02D6DF63F59E35DED33B15546691383BA5C7CC74AFF9D9D8E6706C22F4D48CA6C8C629643A8E9A701A081C43B89DCB0BBCCC15D430663C29327C2BF1C8C8FA7C4926590E700DE1E4F3D7132DCE332DDB7CC9B91887E06B332792B90F9E1A9E9FEC96C49059DF12400C06F46926E53F49A06CBC7FADCD735DB4C8C2EFD9594C8F3E7133F1E889D8A0AE50EEAF1241C0B679F3B9FE876F1F7F7BAEEEB7579CD4C8D2139903C7434F87430755C9013DAFFCAC9C96ACA44A6CA99C89BA723AF4FA6CE4844281E498534C423D9F1A158FFFEC0D3BDDEEBAE69DAE9B3B6A39AA96413C9232743CFCF5A5FD8DCE3BDB904429988258FBA3FF074FFC4332597729A1AEE5FF97587C6B35A72F300242546CBEF4154B2356D5A12C99C3F167C7A38FE4E569A2E3E5100989ECE8D8FC6FB8F049F6A775F7B55E3EF7B2C1D35ECE48C189D481ED5EEE9F2DC7061FAAD9353BF984C1DD3BE083BDFA0107116C2E1B8F0FA88AA06893A572CD6872A1215387470F8B357FB1EEC73EBA91F8331AE77581E5ADD70555DE22783D3B3C65F81C302785539CC4A91F1F89B3A219414FAFCB9E96FEE0F0EC6845A87C9F47424F7C89E8085C53A67151369E96BFD532F0E25D3350B58C572F26F86937B03E99DBDCE3F5D5BD7609D436F0C4C0B5F3B10DA3596AAFD3D0F49818168F691FDB95D63C92F6D6858EDAF6029094AEA50E0A72742CFE58AF1AB68746B7F4B8BD3AF5EF8AE42E539060B317230F8FC50AC7F6BFB43CBFD37D550890410D1504A8A46DCAA6E6999CA0072194BB99215B0545F8A4F8D498642A5D353BFEA0F3C991482B52F9212A327432F8EC50F6D6879A8D7BF9DA9AE1249F1A87474F2BFB2F2B4941F0850C961B30DF7F658622229148E2000A804450D8768E6420E0E7F61BDFF63CBDDF39AFF984DFCBA2667A3831C9C58124A47F217D3CDE158FCF5DEBA9D3CE39CD350FCEEA1C9EF1E0E254545CFCD510A1949D7912722B9BFD913DC1BCCE88CA42645E58993D3C309F12B9B1A977A4CD50E3B16CE7DE18DF163E19CDEA98B42DF184B7D3A257D6553E38D6D76ED1B4889536F8DFCCB6074B752C58F556C7F96CC09815005F4E54947738197CEFF53564EAE6BBCA71A87B45859556C349D3E15BA782716A84E1F08FCF8D8E4B3A292D6F9C8316162F7F0B70425B3AAE19E8A1CD2B2678CE502358606764663EC1E8E115294ABA0F679004A0B40A2192410002013833E7BB56FBE04AAC2F37CBBDBEF34FFF12BE7A7A6B383F3E2309E1B896507EBED6B6BEBC01F1C0DFDE38109E9223F115576F67042FCE21B81C3A1EC7C27A5AF8DA4B252E09F6F6A6DB1577873A7A3B92FBC3E0F02672DEA69E17FEF0DF67A3ADA1CDC4CC77A73E4FF9D0DEFA2F9C1740ECD70911ED19C9C79EDC2F71130EB9BEEA96897AAB9A99AA640E52B2168B1B6D4A961CAE32BF3F35451E9D0C4D307034F29F374B9E7E4F4DBA3DF0340AB1BDE5FEEEF2D599F59FB71E80C845319E968305DF22A685E25E2425E672987B7B63B1EEC732FD8078831F65ABB37B67EF2D5C1472425A59F4351C986D3276A43F8EBA1D8B70E4C4865EBE23102A789F55B5897990967E470464ACF5110959668D76FF6878E8432E5BD96C5C86761EA2D1C4610CC48D1AC523EA3DB3791FEEAFEC947AE6F2EA95B9314C9370E848E4E5500DBC9335D2EBEC1C6B20805D2D248428CE6941277F47DBDEE461B3B33BD3936F9C2D9C86E05CA9F9DB1F17E3B5F8700B92CAD255DB9AA031DF36E53A3D35467E15C29311C17420961AA2416975532AF8F3E516FEB6E77AEAEAC198A7A5EE566A6FA345AF151A8A4C7234056CEC3E2529DCC31D6F28B9D8FBE7930F8945C4620468C95F33AF83A841842E5A43099916225AB080425BD77FC475E4B679B6B5DEDE7ADD0F311C333368EB158F93A0C4CFE5ECF4533A1B4A05ADBA81C57502378451C36D9B84FAFF15E7C1DD176D7A66EEF8DA7A75ECC6B5C7D1C4EA58F132A55F3538D27C57FD8174814976CC208BADDE60FADF0DFD8EEACB371368E4908F2504C786930F6DC996828A36B2C7C6928FEFCB969A5982E1383AE6F71EC5CEABEAACEE235B3184134AB9C8CE67E7A2AFA762095D50C040A85E7CF4D5FDF62FBE0D222E7FB7F9E9DFECD70BC64B6E33431F7F6B83FB8CCD3EB3159588C00B232BD90109E3D1BFB8F33D3E1AC0C001616FFD9FAFA4FACF2CD0C8593A981FE89FF9088AC7D9318318DF6E5AB1B76B43AD658390F42485B40A4CCB7317B56B7FBEA0DCDF7B6D8FBCCAC9DC19C4CC494181D8A1DDC1B7826941ED2129110A2AF8FFCF8BEBEBF36B3F672CD509216472BE884A28E8B11D3EBD964E3BD25875958075F1C6928314739C67C7BCFE7EB6DA52E0333EB28D9931026F78E3D99958AAC5004D86FEB5EDBF0FE56D75A3BE7470811AA24C5A9A1E9BDC7432F4E67C7B428A6C4D83B633FAAB32D31B3CE1A9ABF784433B7BBD62EF3DDE2B776995907428C95F3E4213C1DCE6445450D06D2EAA671C1BCC108607B9B6DA56F114A1532985F51B76368FA4D418EEBE7309E1B11959499AD1C477AFE6CF47438A37D392C4677F4B8FF6A4B5BA7DBA4D1217C939DDFD86CBFB3C7FD95D7478E8532734D0694C74F4472C5DAD5C9339F5DDFF0E00AAF8367B43B3B5DFC0DADF69F9C8A7EE34030AE190E72327DE244E4967687D79C6FFC50467EE244B8E4B24D76EE6FB7B4DCDEE5D41A1A0E1EADF65B967BCD9B9B6D5F7E733C9092FE6095FF13AB7C337E574295A3A15F26C4A25A550CE25637ECD8D2F6B0A54AD9185A69A52C83D80D4D77DFD8F19045D37D396CF2989B3C8D7775BAD6BE34F89D33D1BD5A0E87E24706630757F8B7D5D60C54C7BC9141ECB5ADF757D4ABB5E38494222BEF759AEAE73C7120F25A283354EC7DC45D9E6B6FEEFC1397B968A980CF62F3593A7BBC5B5EBBF09DC1E9BD5A0EC792278662FB96FBB7978F29E5E2E0EBAE6FFF83A5DE1B4A2296793D767A2AADCD98A0D5167251558895453BBA9C7891127DFDD6DE06DB4A9A1F320BA90F14D1A2049AA27C9A9C141766D75C174928233D75728AD0A23C8AED5DAE476FECD012A8E573738BE31BB774767B4CB53366FA83E9A3A18CB6354C187DEE9A864FAEF16B09D41A8A0FAFF2FDC5C6461B8BB4671D9E4CBF3D9E9A75898D27CF4673DA031C1CFE9B6B9BEFEC765534F5598C6E6977FEF3CDED7FBEA1E1D3EBEAB4918FA4387521D6AF5D1948295E5177C7D6F64F5A6A166E2A7B60B4B6E18E9B3B3F61295320AA782D2D772DF94CAB7385F62C898847A75E958B63EE338069B74A96673E6780CE260FE8ED5E0BC898C94AF19353BF5528D5B655877BE3ADDD7F5642E08C78CC6DDBBB3FD7EA5CAB3D4522F2A9F0AE9247562DE492CDC4BA6FEEFACC8ABADBCA730630000832198E650B3D80E8E1B0CBC9ADF22F5AC55E06F36DEE8D40B17E0E2592CDC9B1CA3EC6C9F4604CD0DE72B39DFFE2B5AD7E6BAD18EBEA7ADB673634F30CAEB684945078F9425C5014ED1BBFB1CDFEE00A5F8D593187D187977BEFEC766BCF9208796928AE462C0985D747939242B47FF2CE2EE7ED35C7388C606393ED4FAE6E28813F903C19CB85B4DDDD6369DFDCFA40ED822EE5A38EDFDABEADEDC3A64AF3A8197199EAB7B67D84632CDA134712276342A89226449A4DD73DE8C4A9BCBBEB3933983E3B9519D6369485F36E6E79C0C43A242254DBCCAC7343CB8778C6AE3D31901C48143F72A54107AD6FFABD9E2A79B0AC1AA6CF880AA504002340501C27CC777C5CF8170000FA3C2627BF985509FDD65E8631CB4A46F5BBCE69972A444C8B93152F7560222516471AEE5AE259EA9D3B65E9B62EF70F7D9643C1141407480B2E19E55828A3B5334C0C7E60856FCED2C026067F64B9F7D78331ED1CF55828131314BF854D08F2D15091E56CE3F0EFF7F94C8C8EA06B19A563891372B1CB64B9FF1697A9716E4D52DC71977A37BBCD8D73DE4097EBAA66FBD2A1D8114D8C311EC98EF92DADA5F3BD798628F43B6BE982B2CF27520362B1FA1294ECAB17BE8BE64A0B23549148912B2F25C54299F3DEE2472EB907A7A961857F7BB5BC591600E239399CCA0155C31B08019EE1B0A8E530CE4F0911ACF059F0A296DBB1F13E0E3B24255BC06F0E0E091099E42ACE108662396D1398587C73A75BCFDDBACDECB5AD8E83C510D2D979BC12C94ADA61B6DDC9ADA9B3EA79BA153E4BA7933F36353BE78CE7E4584EF65BD8A448623909E8EC6B6D7398967A17626528540E67C7B52E010E9B5A1CAB749A735A7768B77B9DAE381363E9715F33A88150A6725C98AA1D7EA818AC2F8F9AE80491E8084256086F660325BE939C9C1B499CD4DDD8DA880B89E526CB35BF764FA3BDAFC63495050042A9A2284067142029708820BFCC1D8022206A981E03809D5BE48A571C36B3D84C28C208747258F13A8242822951FB3E5D3C6E75E8CD36EE7499ABE592C8844A0AA11A5A3C66EC34E93207EC3CB3C4CD1F0DA534AE39299A95C103D19C941464ED1F75F2786185F709550425AB1DA479D6EE34CFEDA228493AE1B0D551E696AC2656CE55D29B23D9606DA74B354DB8B0E554253DBE1AE15A91891813428B58B6289C1D2BB9A592E0B4DBD28AABD7B32E049788428982F08CAB86685267F2D9DB88A2425BE1455FED821083304B01F473586D0138A5456F90C1C031FA878CAA09DC840255C842465D008C80C3A8E2B9AC6A002D46C9414A894249F14D318C8E4CF7926766305F7B3658AC114A3B7D564E952B2B6DA7C4958A17500A0B58DD8F003198A745F4523DEB09CB1AEAA2A47CDC2EB9B8CBD450E374B6F0FA28104241CD0CC5C5510A15480208438143852C72F93359110439430B536D5D1C567C1E84EC1CA36D9558569A488A1D2E5D065E342B5563806710539C519B961441267A56486465321CCF69CFE51850BD9A6E336BE390D6828E66A5A4A82C60E145564E26C469AD5AC0D884757C5080E809A6EB9B9241E5CCB2727314CDA909F5088B79A7A941DBE325452A1F05CACF72999A081C5EBCC994B7B6395A9B7716006C3CEBB130637145EDDC085300869658BEAA998A10500C40CF44B38B0B61564E084A9616E8D7C321AAB4C491635087CBAC7DE8AC48FA03C9CDAD737FD44590C9DEB184F65C8E41F536AEE05F41760E6BE3E9A3F1DC502C7775E3DC5FB0198E0BE7A7B3DA73DD2646BDB29D67EA2DDC787C36BF7C22219E0E67EADBE7FD298889D4B9B810D1F648075F572DC600D5C9A1F38490CEF318BAD063AA98FA1EEDC1329587E247967937D53ECB69F297282B06B176DE83165459D86F69AB617ECF69DCB0006066B19DC39490BC9251570E62A6CAAB2208D0994836AB4F09E894687644503214102EF056E0502D4553CA21469C95AB3CDB59D36043886A5BE1D981F0EFADA86BB4CF31333C3C99EA9F486A6D25B799EB729B67DC364BBDD6D3E1ACC6B9A23C3310595D6F636BBA7D0885E70622E1B4A4ED591D4EB3DBCC02808367D634D8B4DEA094A4FCECC4D48666C7BC9A5754B2FB265E2CF1F835DA7BE65E7D4B2B54E09E1F877315E5A1E5DE513AF740A0F31E5A1DCB1170DA351F27C27B3636DDED3537D538ABC5B19CC1BC36BEC7B3B67B7AFFACC1B690E229D6B2916E5E0D8855FF6183DD0454A18450A2A83F00512A440B0955BF23712E9A1D8D0B8B6652031D491C5188A2EAF1993821A188CC460B8BE28718F3A62A63FCBA267BBDADA8E71D0FA5BE7730503B937B22297CFDAD9158AE68ED4C9FDFDAE234156C18745387934545A5209E3E39F5DBA158EDD9C5FE40F2A7C74384CC9E8581DED8E15219C3086EE9749998A268FEAFCE469F383AA93FF55CA1F2BE895F9E9B3EAC2E925637169997B8AFD1A7CA161E282F0FB2573035CB8A0B574A5B2B3940EF0DB4D87BDDE6465230AA09402833B66BE46739A556FE53937D89C7DCA2FD8B29317138B4CBCCDADDA6FA6A9B99B59F8D1E40804AF69765D2A1B2E74573408811EAF65A55F0F2737BAA50A200518012AA4511F2A1C7C994F0CA506CB1204C089343D30767F023C5BC55E4D0C4382D9CAFE2D5BADC961B3BDCDA3E4D08FDC1A1897FEB0FA8B527CA65349EFBCBDF0CBE3912D39EC522B87799CFC6CD5A04DB3A5C1D4E1E2899D9A219F14BAF0EBE3218ADC821A1B0773CF1D7BB0683C99CF6AC263B775BF7EC37A736343BD6D459B4076425F96B6F8DFCF04850D0F1613641C9BE3DFEDCCB171ECF11410198D91AEC4B5A9D7DFA4DCA85D568D11361A71A426A2C7A58D86D384DFEE5FE2DDAC8B842E9BEE0AF7F35F8FDB414AF7A16EF5BEEBF8E00D2B6D8E1D06BBF1AFCF764A535C1009014A3BF1AFCF767CE7DFB99B3DF2A0FC3947A478BB7B9E78400B0B2D1C90055084133A57871617659E2AA51D7141278EAE4D40796F99A1DFCC5ABC153E1D7A3B9000220286F8E128D5D0A141144717E3698B74B6D7C43B50FE8710C7A704DC3CBE722D1EC6C4E7652901F7BF3C2C189C41FAE6F59516FB3710C4620131ACD4AFBC612DFDE37762458FADDC5157EDB2DDDDEE2E1D3B473B9FF1B6F8F6A8F1C8F0B9FFFF5F98FAE49ED5C51D7EE3499D87C1252302D3E7F3AF2BD4313C1E20F1E6204EF5FEAEBF65834462FFBD0558D4726D35AE41282F2E81B23A7A6D20FAC69E8F158D44238EAC509556422835A81223DF84EE08581E9035251C531E018D39696F75BF54D08E1E28AFFCE598A404FF8812ED41C45803634DC7E38B47B3A17D2042194B7032F8432A3D7B7DCDBEE5C6661EDE566F9FA86DB8E4EBD1ECA8C6AE7937B02BF184F9DBFA1F5831DCEE536CEC56096502523258713275F1B7D6A387182023D19D9430176F67EDA65AA9B9F87BD36842B1A5D3E0B379916675A4B0D0DE67D33B3A18BD9FCEE33E1F4CF4F863EBDA185BDB8B0FD54E6C28189E708503528A99343AFB5B746E19DAB9B1C1F59D3F09D7D635A5A0499FC6220FCFA85D852BFB5DB63E1199410945353E9E178AE5CE1B84CECE7B6B4974C233182075637EC1A9ADE1F48163F82F88F7B477F727C72A9D7D2E63203C0644A188864C79342B9865C5E677B686D63499BDDD5EBDB3D1C7BFAC4A4F6F8B4487E7C34F8C240B8C36DB670B8DEC63FB6BDC76FE54E45F6BD3AFA1400A4A45842982A14FCD32C0540684DDD0D2B7DD7E99FD45D4C8864CE92E5A4E4FB87156DB38BB8877A6BFBD6960FBC30F43D85C81A135D19983E783E7EDC636EF098EBDDA6BA066BFBB6960F3085554E7E4BCB0DADF73F7BEE3B4271E58BA1F8C9D1E4A35E7383DFDAEAE4BD293116CE8E477313DA763E117947E5D05D91C3F25514540784CD4ECBD23A7B28394531A042991535414CF54E0206AAAE632AC40708817FED9F58DFE4D8D6BEF04FBAE6E4D46BC33F8AE4821800A37C5052CB21A280D5198486438CF8F2EAB1C53E68F4A90DAD67C39957CE474A3088E7A4FD63F1FD63F11AA7730C7A686DE3F6EE0A01EB463BFFE56D9D9F7A61603C219478F98309219898639EDCEC307D795B6779BCC4C2E1BFB8AE7D783ABB77ACB414453C271F0DA600A0C56952078B84181D8C1FAFF157DA1DCB6EEBF828CF9816E6E1BC48EFE8626942FD8210DADC7C57203DBC2FF8EB92E560A2224EA64727D3A300D0ED5A755DF33D8CA69AC4BA869B2732C36F8C3FABA5170044220633A3418D922C1F784E45FB4F470F6C6E7ADFC2C236A5734200B099D89B96D4234210512855F293434AF25344D54F4348DE555370A84533D2FFDA3D7C726A81934341C9FC76F8F15391B7295507CBFCDDABBF6ADD3325F3432BEFAB9BABC4B2DFCA3D76DB925BBABD18AA66A257DC380C0FAF6DFAD3CDEDD542FC1B5A9C8F6EEF6E76F055B28EAB6ECD0EFE91EDDDDB3A2A7F81B8C5697A647BCFA6560746352E52E8AF553F5784DA1C7D1FECFD539FA5693E20957856E66B8ECE75BA8ECF2A95FB87E6750F26C6F2BEAE8FADF65F87103347F315070C6FEFF8E896A6BB3162E7D34780C3A62DCD3BD6D6DD5075609ACFA7BD669DE037F4367ACD2C220411422981BCA754C3212D704866393C3E997CE2F0CF46A60F29CAFCCA1E67E4E4CB177EB837F00B892833E0A9BCCDC961B3635DF9970C2AAA9DAFDEDE7BFFEA468BEE2C30BF95FBC2D6CE2F6EED7254CF47C3086EEDF17DEBCEA56B1BEC3A09C740D7D4DBFEE18EDEDB97F86A18EFABEA6DFFB2A3EFC3AB1B1C3CD2FA6966B7C2D04F2A6D2C63BEA6E1B684FE4AC5000007C74944415487567CA9D5D13BDF495D69D6FF7C6CD139972991D255140874803A5FABD86DAAFBD0B2CFDDDCFEFB66D659BEB4A29A8BD2CC5AEFEAFEF88EEE4FDA791FA9D2B0259BD354B7A3FB0FEFEAFA8499AD965784CA9E17CD6D8E02C0B206D7DA56CFAE33F954548AA010BB0720F9AA02289FDA8D29295403A6349239FBDAD06FFAEA3EBAAAE1162B6FD7F1DA68203DF8CA851F0D44F702281880500488A2BC4708614467EC5254F8260CA148B54B5964E9F1DEA8271144E5F0D15B7BB7757ABEDF3F7E3898ACE1F4B7F1CCB56DAE4F6D6CDBDCE69A73968B115CDFE1FEF77B97FFE050E0D993A1894A733FAD8ABB6779FD1FAC6B6ED391B5D3E2343DBA7DC96D3DBE1F1C1CEF0F2492DAE200B472D80D0078C6D46AEFD9D67ACF1AFF75FAADD0453105F51C5F9E3B5A0E18BD88AC9DD9781DE7B8B3F3634BDD6B5F1DFDAF73B16325933D5A5D8BDED8BAB3D3B9FC95E19F9F8D1DAB917063E51CCB3C6B6FEDB8BFCDDE8BAA97C32E7F41BA1C33AA457ADFBAAEB7CE4D8A6A4A1A064A66CAC9CC1622CD2FBEC79852945F1C454150A6F607FEEFD1A93D1B5BDFDFE35965E32A3BE5142287B263FB83AF1C0EED8A0B618CF2B34C0C54658C9471A8FD469A7A8CDFB6A4D1BE42FF8BB17078E78AFA1BBB3CBB87A65F391F393E990AA7A5B4A4CC38601A1DFCD54DCEBB96F9D7373B6DF3599FD5E632FFF50DDD1F5EDDF8CAB9C8AB83D1E1582E969366AAF4BACD5C87DB7C6397F7B625BE253EAB7EEF9589C577F4FAB676B88F4E26770D4E1F9E488EC673824C9A1CF9E54D3C63769BEB556BCA63F2B73A7A967BD67538FBAA35FB9C132A07EFF168F2BC5DBC8F417ADB81672C9EE21C712BE72CEBBB4EB7E6181E9B18CC951FE399EB183DC2607699775DA76BF985C4C0B1F03BC3C933B1DC94480441C9D6F8A01A42A8CBB5E2E1955F1A4B9D3F1A7E7B307E723A379591D30A9518C459599BD75CDFED5AB9DABFB9D5DE33E73037F382B47B6A465A358352242D3CF8BD57F75F8800C280314198628C30068C11C28019843142186106300684556D786FDF731B5AFA012023A360CEE6B6752DF55EB5C4BDCA6DAAB3734E0090881817A281F485D3D18323C93349318201D47C708C000355FF45453B0B3F03200408A8BAD29145ECF69ECFAFACBB6361B35099D084204FA5C599A07CBD8DF75A388789C117F7DD9BACA44CE7E4504A141402002606D7DB798F99B57017BBEA5290C9744E52086530F25B79162341C9A6A524003088B1B0F605A8BEB208584C5B829E418C8377EBB435666E46AB584A8683B494D42A258CB09D7397D4622A390621EC283B66417E876C564E67E574464A9A596BB3AD0BE978D1EA4325A598AC883C6376F06E0B6B33E9AEA25FDE2636CE51E37454E24DFAF9FEF39FFDF91E890020049899E5101568C40CCAFFCCA8E9DEF7F63DBFA1B5BF30D343236936079865391E9B55A35921524EC9683F9D5384D97C386C71ACBCB7EFFFD4AED4608821BF5B52EAB1B86355DB0D4B9B2821400910051305110244F5D3E4BD35B3FE52B51686C6E2B5B2B4DD269B81C8B2949553D3B9D0742E9410A78B3F5E0584AAABADF39F5B525DA34AFEEB4B333B41EBA7A180586C59DF74BF41A0219739842E0BFFB95B57D73BCD94A8F56608260AE4FDA54A9EC37C96693ED1B4D4B86769BB4D3601A9EDDD2AE790CEC561AF775B9767A3F1CE0CB9CC210480751D757FB46D39CF2015399543449402874A411F2A79F558469B095313103AD7AAC979E9439FB5EBDAD607396C32DE9921973F842C461FBF6ED91DABDA30426AC01028C184E0BC8D3ABBD2424DF2D6567C000085C05812C7245D9E8E120E69150E79C6B1ADFDE325B5740C31E4B28550354ABF72F7FA35AD5E50AB45100294A8717CA06426765FF8A194C0B0C8600E237D5E794241A9C92146FCF56D1F5DE2DD6CBC2D43AE200801A0CBEFF887FBAF5DDDA2E190E4394444C3219D5DA8A11218111986D74BA02AB4C02129E31001774DD3DDD734DDADE76394861872594108006B5A7DDFBCFFDA95CD9E3C87B4C0212548EB2FA5544B209E27815A0E69318780B80DCD77DFDCF1B0311534E40A851000D6B5FBBFFD91EBD6B4FA341C2AA810B728E8437A910456E410236E53D3DDB7767E5C7FE52F430CB90C2154F5E1771EB8FED615AD2C46B3FA90E651A48428848EA52E96C0120E11663737EFB8ADEB618340430C0801009637B9BFFD91EBFEF8A6952E0BAF7E1006F246A98228199A768745FEE2099CE11030BBA5E9EE3B3A1F361B041A72054869DA5A0D1115B27B20F0F5978F1E1C0E1335EF1A618A31CBC9AB7B0F2E6D3B85F12214236530BBB579C78EEE87AAAF1331C4902B15425582F1CCD3FD433FDA73662892A280F21CF2F29A25077B2F9A438340430C087509A174249A7AE1C8C8CF0E9C1F9C4A89041685438340430C08E72DC17866CF60E897C7C7FA47221349816071CDD283BDAD0BE1D020D01003C2858B4C682096391D8CED1B899C990A3BBCBB19EB7E3D1FE5300834C490C581502BA2429242EAB7634FBE1578B1A4829541A02186BC1B10AA9293332F0C3EFE46E0853939340834C4107C292E6A66AD3BBA1FDADABC83A9599EC020D010432E15847A38340834C410552EE1D20495430028B74B19CC6E6BB9FBAEAE8F19041A6208BEA457AFA80F551D6810688821975C1356D4871CE6B7B6DE7D67E78306818618F22E41A8E570CFC4AFB734DF7157D747F5977034C490CB5E2E4988A2A2E4E4CCD9D891A59EB506818618F2DE406888218654146C34812186BCB7F2FF016D3E1300F2F87FDE0000000049454E44AE426082";
    public static final int COLOR_TYPE_RGB = 1;
    public static final int COLOR_TYPE_CMYK = 2;
    public static final int COLOR_TYPE_YCCK = 3;

    private int colorType = COLOR_TYPE_RGB;
    private boolean hasAdobeMarker = false;


	/**
	 * Scale a BufferedImage to a maximum height and width
	 * @param src A BufferedImage
	 * @param bounds A rectangle specifying the maximum height and width
	 * @return A scaled BufferedImage (getScaledImage from BufferedImage returns an Image 
	 * 			which is not so handy)
	 */
	public static BufferedImage getScaledImage(BufferedImage src, Rectangle bounds, boolean upScale){
	    return getScaledImage(src, 
	    		bounds.getWidth(), bounds.getHeight(), upScale);
	}

	/**
	 * Scale a BufferedImage to a maximum height and width
	 * @param src A BufferedImage
	 * @param bounds A rectangle specifying the maximum height and width
	 * @return A scaled BufferedImage (getScaledImage from BufferedImage returns an Image 
	 * 			which is not so handy)
	 */
	public static BufferedImage getScaledImage(BufferedImage src, ImageSize bounds, boolean upScale){
	    return getScaledImage(src, 
	    		bounds.getWidthPoints(), bounds.getHeightPoints(), upScale);
	}

	/**
	 * Scale a BufferedImage to a maximum height and width. If the width gets scaled we adjust 
	 * the height but then check whether the height is within the bounds...and may adjust 
	 * the width again (but it's only int operations, we don't actually scale until the end!)
	 * @param src A BufferedImage
	 * @param boundWidth The maximum allowed width
	 * @param boundHeight The maximum allowed height
	 * @return A scaled BufferedImage (getScaledImage from BufferedImage returns an Image 
	 * 			which is not so handy)
	 */
	public static BufferedImage getScaledImage(BufferedImage src, 
			double boundWidth, double boundHeight, boolean upScale){
	    Rectangle scaled = scaleToBounds(src.getWidth(), src.getHeight(), boundWidth, boundHeight, upScale);
	    // Don't scale unnecessarily
	    if (!upScale && src.getWidth() <= boundWidth && src.getHeight() <= boundHeight) {
	    	return src;
	    }
	    BufferedImage resizedImg = new BufferedImage((int) scaled.getWidth(), (int) scaled.getHeight(), BufferedImage.TYPE_INT_RGB);
	    Graphics2D g2 = resizedImg.createGraphics();
	    g2.setBackground(Color.WHITE);
	    g2.clearRect(0, 0, (int) scaled.getWidth(), (int) scaled.getHeight());
	    g2.drawImage(src, 0, 0, (int) scaled.getWidth(), (int) scaled.getHeight(), null);
	    g2.dispose();
	    return resizedImg;
	}
	
	public static Rectangle scaleToBounds(Rectangle original, Rectangle bounds, boolean upScale) {
	    return scaleToBounds(original.getWidth(), original.getHeight(), bounds.getWidth(), bounds.getHeight(), upScale);
	}

	public static Rectangle scaleToBounds(Rectangle original, 
			double boundWidth, double boundHeight, boolean upScale) {
	    return scaleToBounds(original.getWidth(), original.getHeight(), boundWidth, boundHeight, upScale);
	}

	public static Rectangle scaleToBounds(double originalWidth, double originalHeight, 
			Rectangle bounds, boolean upScale) {
	    return scaleToBounds(originalWidth, originalHeight, bounds.getWidth(), bounds.getHeight(), upScale);
	}

	public static Rectangle scaleToBounds(ImageSize imageSize, 
			ImageSize bounds, boolean upScale) {
	    return scaleToBounds(imageSize.getWidthPoints(), imageSize.getHeightPoints(), bounds.getWidthPoints(), bounds.getHeightPoints(), upScale);
	}

	public static Rectangle scaleToBounds(ImageSize imageSize, 
			Rectangle bounds, boolean upScale) {
	    return scaleToBounds(imageSize.getWidthPoints(), imageSize.getHeightPoints(), bounds.getWidth(), bounds.getHeight(), upScale);
	}

	public static Rectangle scaleToBounds(ImageSize imageSize, 
			double boundWidth, double boundHeight, boolean upScale) {
	    return scaleToBounds(imageSize.getWidthPoints(), imageSize.getHeightPoints(), boundWidth, boundHeight, upScale);
	}

	public static Rectangle scaleToBounds(double originalWidth, double originalHeight, 
			double boundWidth, double boundHeight, boolean upScale) {
	    double[] scaled = getScaledDims(boundWidth, boundHeight, originalWidth, originalHeight, upScale);
	    return new Rectangle(0, 0, scaled[0], scaled[1]);
	}

	/**
	 * Try to get a Color, first by name and if that doesn't work, then we presume it's a hex string. Returns BLACK in
	 * case even the hex string is not parsable.
	 * @param nm Name of a Color (yellow, black, blue...) or a hex string defining (alpha)rgb
	 * @return The desired java awt Color object or else BLACK
	 */
	public static Color getColorOrBlack(String nm) {
		return getColor(nm, Color.BLACK);
	}

	/**
	 * Try to get a Color, first by name and if that doesn't work, then we presume it's a hex string. Has a final
	 * fallback Color in case even the hex string is not parsable.
	 * @param nm Name of a Color (yellow, black, blue...) or a hex string defining (alpha)rgb
	 * @param fallback A fallback Color in case something goes wrong.
	 * @return The desired java awt Color object or else the provided fallback Color
	 */
	public static Color getColor(String nm, Color fallback) {
		try {
			return getColor(nm);
		} catch (Exception ex) {
			if (StringUtils.isNotBlank(nm)) {
				// If an unparseable String was provided, WARN the user that the fallback value was returned (this
				// fallback event might possibly be an attention point)
				log.warn("The color \"{}\" could not be parsed, so we will fallback to {}", nm, fallback);
			}
			else if (fallback != null) {
				// If an empty String was provided and the fallback is not NULL, INFORM the user that the fallback
				// value was returned (we just assume no explicit value was provided)
				log.info("The provided color is empty, so we will fallback to {}", fallback);
			}
			// We don't care logging a fallback event if both the provided String is empty/null and the fallback
			// Color is null
			return fallback;
		}
	}

	private static Color getKnownColour(String nm) {
		Color result = null;
		switch (nm.toLowerCase().replaceAll("[ _-]+", "")) {
			case "brown":
				result = new Color(0xA5, 0x2A, 0x2A);
				break;
			case "lightblue":
				result = new Color(0xAD, 0xD8, 0xE6);
				break;
			case "darkblue":
				result = new Color(0x00, 0x00, 0x8B);
				break;
			case "darkorange":
				result = new Color(0xFF, 0x8C, 0x00);
				break;
			case "lightgreen":
				result = new Color(0x90, 0xEE, 0x90);
				break;
			case "darkgreen":
				result = new Color(0x00, 0x64, 0x00);
				break;
			case "violet":
				result = new Color(0xEE, 0x82, 0xEE);
				break;
			case "indigo":
				result = new Color(0x4B, 0x00, 0x82);
				break;
			case "purple":
				result = new Color(0x80, 0x00, 0x80);
				break;
			case "rebeccapurple":
				result = new Color(0x66, 0x33, 0x99);
				break;
		}
		return result;
	}

	/**
	 * Try to get a Color, first by name and if that doesn't work, then we presume it's a hex string
	 * @param nm Name of a Color (yellow, black, blue...) or a hex string defining (alpha)rgb
	 * @return A java awt Color object
	 * @throws NumberFormatException The Color name is blank, is not known to Java AWT or is not a parsable hex string.
	 */
	public static Color getColor(String nm) throws NumberFormatException {
		if (StringUtils.isBlank(nm)) {
			throw new NumberFormatException("A null, empty or blank value is not a valid colour!");
		}

		if (nm.startsWith("#")) {
			log.debug("Color {} starts with # so will assume it is a hex value.", nm);
			return decodeWithAlpha(nm);
		}

		Color knownColor = getKnownColour(nm);
		if (knownColor != null) {
			return knownColor;
		}
		log.debug("Color {} was not a known color, so will try to get it from AWT next.", nm);

		nm = nm.trim().toUpperCase();
		try {
			Field field = Class.forName("java.awt.Color")
					.getField(nm.replace(' ', '_').replace("GREY", "GRAY"));
			return (Color)field.get(null);
		} catch (Exception e) {
			log.debug("Color {} was not found in AWT, so we'll try to decode it as a hex string as a last resort.", nm);
			return decodeWithAlpha(nm);
		}
	}

    /**
     * 
     * @param nm RGB hex string that may also include Alpha value
     * @return A java awt Color object
     * @throws NumberFormatException
     */
	private static Color decodeWithAlpha(String nm) throws NumberFormatException {
		final int maxLength;
		if (nm.startsWith("0X")) {
			maxLength = 10;
		} else {
			maxLength = 9;
			if (!nm.startsWith("#")) {
				nm = "#" + nm;
			}
		}
		if (nm.length() > maxLength) {
			throw new NumberFormatException("Hex string [" + nm + "] is too long.");
		}

		long l = Long.decode(nm);
    	long alpha;
    	if (nm.length() <= 7) {
			// If no alpha bits, default to 255
    		alpha = 255;
    	} else {
			// Alpha channel is the most significant
    		alpha = (l >> 24) & 0xFF;
		}
    	log.debug("Creating a new colour with alpha: {}", alpha);
        return new Color((int)(l >> 16) & 0xFF, (int)(l >> 8) & 0xFF, (int)l & 0xFF, (int)alpha);
    }

    // Read jpegs with any colourspace you care to mention!
	public BufferedImage readImage(File file) throws IOException, ImageReadException {
        colorType = COLOR_TYPE_RGB;
        hasAdobeMarker = false;

        ImageInputStream stream = ImageIO.createImageInputStream(file);
        Iterator<ImageReader> iter = ImageIO.getImageReaders(stream);
        while (iter.hasNext()) {
            ImageReader reader = iter.next();
            reader.setInput(stream);

            BufferedImage image;
            ICC_Profile profile = null;
            try {
                image = reader.read(0);
            } catch (IIOException e) {
                colorType = COLOR_TYPE_CMYK;
                checkAdobeMarker(file);
                profile = Imaging.getICCProfile(file);
                WritableRaster raster = (WritableRaster) reader.readRaster(0, null);
                if (colorType == COLOR_TYPE_YCCK)
                    convertYcckToCmyk(raster);
                if (hasAdobeMarker)
                    convertInvertedColors(raster);
                image = convertCmykToRgb(raster, profile);
            }

            return image;
        }

        return null;
    }

    public void checkAdobeMarker(File file) throws IOException, ImageReadException {
        JpegImageParser parser = new JpegImageParser();
        ByteSource byteSource = new ByteSourceFile(file);
        @SuppressWarnings("rawtypes")
        List segments = parser.readSegments(byteSource, new int[] { 0xffee }, true);
        if (segments != null && segments.size() >= 1) {
            UnknownSegment app14Segment = (UnknownSegment) segments.get(0);
            //byte[] data = app14Segment.bytes;
            byte[] data = app14Segment.getSegmentData();
            if (data.length >= 12 && data[0] == 'A' && data[1] == 'd' && data[2] == 'o' && data[3] == 'b' && data[4] == 'e')
            {
                hasAdobeMarker = true;
                //int transform = app14Segment.bytes[11] & 0xff;
                int transform = app14Segment.getSegmentData()[11] & 0xff;
                if (transform == 2)
                    colorType = COLOR_TYPE_YCCK;
            }
        }
    }

    public static void convertYcckToCmyk(WritableRaster raster) {
        int height = raster.getHeight();
        int width = raster.getWidth();
        int stride = width * 4;
        int[] pixelRow = new int[stride];
        for (int h = 0; h < height; h++) {
            raster.getPixels(0, h, width, 1, pixelRow);

            for (int x = 0; x < stride; x += 4) {
                int y = pixelRow[x];
                int cb = pixelRow[x + 1];
                int cr = pixelRow[x + 2];

                int c = (int) (y + 1.402 * cr - 178.956);
                int m = (int) (y - 0.34414 * cb - 0.71414 * cr + 135.95984);
                y = (int) (y + 1.772 * cb - 226.316);

                if (c < 0) c = 0; else if (c > 255) c = 255;
                if (m < 0) m = 0; else if (m > 255) m = 255;
                if (y < 0) y = 0; else if (y > 255) y = 255;

                pixelRow[x] = 255 - c;
                pixelRow[x + 1] = 255 - m;
                pixelRow[x + 2] = 255 - y;
            }

            raster.setPixels(0, h, width, 1, pixelRow);
        }
    }

    public static void convertInvertedColors(WritableRaster raster) {
        int height = raster.getHeight();
        int width = raster.getWidth();
        int stride = width * 4;
        int[] pixelRow = new int[stride];
        for (int h = 0; h < height; h++) {
            raster.getPixels(0, h, width, 1, pixelRow);
            for (int x = 0; x < stride; x++)
                pixelRow[x] = 255 - pixelRow[x];
            raster.setPixels(0, h, width, 1, pixelRow);
        }
    }

    public static BufferedImage convertCmykToRgb(Raster cmykRaster, ICC_Profile cmykProfile) throws IOException {
        if (cmykProfile == null)
            cmykProfile = ICC_Profile.getInstance(ImageUtils.class.getResourceAsStream("/ISOcoated_v2_300_eci.icc"));
        if (cmykProfile.getProfileClass() != ICC_Profile.CLASS_DISPLAY) {
            byte[] profileData = cmykProfile.getData(); // Need to clone entire profile, due to a JDK 7 bug

            if (profileData[ICC_Profile.icHdrRenderingIntent] == ICC_Profile.icPerceptual) {
                intToBigEndian(ICC_Profile.icSigDisplayClass, profileData, ICC_Profile.icHdrDeviceClass); // Header is first

                cmykProfile = ICC_Profile.getInstance(profileData);
            }
        }
        ICC_ColorSpace cmykCS = new ICC_ColorSpace(cmykProfile);
        BufferedImage rgbImage = new BufferedImage(cmykRaster.getWidth(), cmykRaster.getHeight(), BufferedImage.TYPE_INT_RGB);
        WritableRaster rgbRaster = rgbImage.getRaster();
        ColorSpace rgbCS = rgbImage.getColorModel().getColorSpace();
        ColorConvertOp cmykToRgb = new ColorConvertOp(cmykCS, rgbCS, null);
        cmykToRgb.filter(cmykRaster, rgbRaster);
        return rgbImage;
    }

    static void intToBigEndian(int value, byte[] array, int index) {
        array[index]   = (byte) (value >> 24);
        array[index+1] = (byte) (value >> 16);
        array[index+2] = (byte) (value >>  8);
        array[index+3] = (byte) (value);
    }

	/**
	 * Given the width and height of the page size we want the output to be, and the current
	 * width and height of the slides in the presentation, return a double[] of the new
	 * dimensions. If upscale is true, a scaling factor greater than 1 may be used 
	 * @param pageWidth Width of the page in pixels for 72DPI (e.g. for A4 Portrait it's 595) 
	 * @param pageHeight Height of the page in pixels for 72DPI (e.g. for A4 Portrait it's 842)
	 * @param slideWidth Current width of the Slides in the Presentation
	 * @param slideHeight Current height of the Slides in the Presentation
	 * @return A double[] of the new dimensions
	 */
	public static double[] getScaledDims(double pageWidth, double pageHeight, 
			double slideWidth, double slideHeight, boolean upScale) {
		double ratioW = pageWidth / slideWidth; 
		double ratioH = pageHeight / slideHeight;

		// A smaller ratio will ensure that the image fits on the page
		double ratio = Math.min(ratioW, ratioH);
	    if ((slideWidth * ratio - pageWidth) > 1) {
	    	log.warn("Width ({}) will be too large to fit on page ({})", slideWidth * ratio, pageWidth);
	    }
	    if ((slideHeight * ratio - pageHeight) > 1) {
	    	log.warn("Height ({}) will be too large to fit on page ({})", slideHeight * ratio, pageHeight);
	    }
	    // If we would be upscaling (ratio > 1) but upScale NOT requested, set ratio back to 1 (no resizing)
	    if (ratio > 1 && !upScale) {
	    	ratio = 1;
	    }
		return new double[] {slideWidth * ratio, slideHeight * ratio};
	}

	/**
	 * Convert a String representation of a Page Size to an Aspose PDF PageSize object
	 * of the correct Width and Height
	 * @param pageSize String containing e.g. A4, Letter, Legal
	 * @return An Aspose PDF PageSize object of the correct dimensions
	 */
	public static PageSize parsePageSize(String pageSize) {
		switch (pageSize.toUpperCase()) {
			case "A0":
				return PageSize.getA0();
			case "A1":
				return PageSize.getA1();
			case "A2":
				return PageSize.getA2();
			case "A3":
				return PageSize.getA3();
			case "A4":
				return PageSize.getA4();
			case "A5":
				return PageSize.getA5();
			case "A6":
				return PageSize.getA6();
			case "A7":
				return new PageSize(210, 298);
			case "A8":
				return new PageSize(147, 210);
			case "A9":
				return new PageSize(105, 147);
			case "A10":
				return new PageSize(74, 105);
			case "B0":
				return new PageSize(2834, 4008);
			case "B1":
				return new PageSize(2004, 2834);
			case "B2":
				return new PageSize(1417, 2004);
			case "B3":
				return new PageSize(1001, 1417);
			case "B4":
				return new PageSize(709, 1001);
			case "B5":
				return PageSize.getB5();
			case "B6":
				return new PageSize(354, 499);
			case "B7":
				return new PageSize(249, 354);
			case "B8":
				return new PageSize(176, 249);
			case "B9":
				return new PageSize(125, 176);
			case "B10":
				return new PageSize(88, 125);
			case "11X17":
				return PageSize.getP11x17();
			case "LEDGER":
				return PageSize.getPageLedger();
			case "LEGAL":
				return PageSize.getPageLegal();
			case "LETTER":
				return PageSize.getPageLetter();
			default:
				log.warn("Got a bad or empty page size: [{}]. Defaulting to A4...", pageSize);
				return PageSize.getA4();
		}
	}

	/**
	 * Convert a String representation of a Paper Size to an Aspose Words PaperSize (int)
	 * @return An Aspose Words PaperSize as an int
	 */
	public static int parsePaperSize(String paperSize) {
		if (StringUtils.isBlank(paperSize)) {
			log.warn("Got a bad or empty paper size: [{}]. Defaulting to A4...", paperSize);
			return PaperSize.A4;
		}
		switch (paperSize.toUpperCase()) {
			case "A3":
				return PaperSize.A3;
			case "A4":
				return PaperSize.A4;
			case "A5":
				return PaperSize.A5;
			case "B4":
				return PaperSize.B4;
			case "B5":
				return PaperSize.B5;
			case "ENVELOPE":
			case "ENVELOPE_DL":
			case "ENVELOPE DL":
			case "ENVELOPE-DL":
				return PaperSize.ENVELOPE_DL;
			case "EXECUTIVE":
				return PaperSize.EXECUTIVE;
			case "FOLIO":
				return PaperSize.FOLIO;
			case "LEDGER":
				return PaperSize.LEDGER;
			case "LEGAL":
				return PaperSize.LEGAL;
			case "LETTER":
				return PaperSize.LETTER;
			case "10X14":
				return PaperSize.PAPER_10_X_14;
			case "11X17":
				return PaperSize.PAPER_11_X_17;
			case "QUARTO":
				return PaperSize.QUARTO;
			case "STATEMENT":
				return PaperSize.STATEMENT;
			case "TABLOID":
				return PaperSize.TABLOID;
			default:
				log.warn("Got a bad or empty paper size: [{}]. Defaulting to A4...", paperSize);
				return PaperSize.A4;
		}
	}

	public static double[] getSelectedWidthAndHeight(String pageSize, String orientation, int imageWidth, int imageHeight) {
		double[] result = new double[] {-1, -1};
		if (StringUtils.isNotEmpty(pageSize)) {
			PageSize chosenPageSize = ImageUtils.parsePageSize(pageSize);
			boolean landscape = imageWidth > imageHeight;
			if ("LANDSCAPE".equalsIgnoreCase(orientation)) {
				landscape = true;
			}
			else {
				landscape = false;
			}
			if (landscape) {
				// Flip the width and height as it's landscape
				result[0] = chosenPageSize.getHeight();
				result[1] = chosenPageSize.getWidth();
			}
			else {
				result[0] = chosenPageSize.getWidth();
				result[1] = chosenPageSize.getHeight();
			}
		}
		return result;
	}

	/**
	 * Get the nice full DocShifter logo from the Beans jar
	 * We may return null if something goes wrong, so callers should allow for that
	 * @return BufferedImage the DocShifter logo
	 */
	public static BufferedImage getLogo() {
		return getLogo(null);
	}

	/**
	 * Get the nice full DocShifter logo from the Beans jar
	 * We may return null if something goes wrong, so callers should allow for that
	 * @param data
	 * @return BufferedImage the DocShifter logo
	 */
	public static BufferedImage getLogo(long[] data) {
		BufferedImage bufferedImage = null;
		InputStream in = ImageUtils.class.getResourceAsStream(DS_WHITE_LOGO_FILE_LOCATION);
		try {
			bufferedImage = ImageIO.read(in);
		}
		catch (IOException ioe) {
			log.warn("Could not read the logo from the location: {}", DS_WHITE_LOGO_FILE_LOCATION, ioe);
		}
		if (bufferedImage == null) {
			bufferedImage = getFallbackLogo();
		}
		applyData(bufferedImage, data);
		return bufferedImage;
	}

	private static void applyData(BufferedImage bufferedImage, long[] data) {
		// We are applying data... an array of usually 4 longs to an image
		// The data is encoded in the image, in the top and bottom lines of the image
		// The image should be at least 130 pixels wide and it's best if there is a
		// continuous line of white pixels at least as the top and bottom line of the image
		if (bufferedImage != null && data != null && data.length > 0) {
			// Create a graphics which can be used to draw into the buffered image
			Graphics2D g2d = bufferedImage.createGraphics();
			int idx = 2;
			int idy = 0;
			// Generally we allow for up to 4 numbers to be stored in the image
			// Here we encode the number of items less 1
			// So 1 item will be encoded as 0 = 00
			//    2 items as 1                = 01
			//    3 items as 2                = 10
			//    4 items as 3                = 11
			for (int cntBit=0;cntBit<2;cntBit++) {
				if (((data.length - 1) & (cntBit+1)) == 0) {
					paintBit(g2d, cntBit, 0, '0');
				}
				else {
					paintBit(g2d, cntBit, 0, '1');
				}
			}
			for (int didx = 0; didx < data.length; didx++) {
				// Get one of the numbers as a String of 0s and 1s
				String binStr = Long.toBinaryString(data[didx]);
				// Make sure the binStr is the full 64 bits long
				binStr = ("0000000000000000000000000000000000000000000000000000000000000000" + binStr).substring(binStr.length());
				switch (didx) {
					case 0:
						// Top line of the image at 2 for 64 pixels
						idx = 2;
						idy = 0;
						break;
					case 1:
						// Top line of the image at 66 for 64 pixels
						idx = 66;
						idy = 0;
						break;
					case 2:
						// Bottom line of the image at 2 for 64 pixels
						idx = 2;
						idy = bufferedImage.getHeight() - 1;
						break;
					case 3:
						// Bottom line of the image at 66 for 64 pixels
						idx = 66;
						idy = bufferedImage.getHeight() - 1;
						break;
				}
				// Go through binStr taking one 1 or 0 bit at a time
				for (char c : binStr.toCharArray()) {
					paintBit(g2d, idx, idy, c);
					// We only ever move along the x-axis, either starting at 0 or 65 (so
					// the numbers don't overlap)
					// y is either 0 for the first row of pixels or the height -1 for the
					// last row
					idx++;
				}
			}
			// Disposes of this graphics context and releases any system resources that it is using.
			g2d.dispose();
		}
	}

	private static void paintBit(Graphics2D g2d, int idx, int idy, char bit) {
		// A zero bit we mark as 'black' albeit only the tiniest bit
		// darker than white imaginable (think Planck)
		if (bit == '0') {
			g2d.setColor(Color.decode("0xFEFEFE"));
		}
		else {
			g2d.setColor(Color.white);
		}
		// Fill a one pixel by one pixel 'rectangle' with the chosen colour
		g2d.fillRect(idx, idy, 1, 1);
	}

	/**
	 * If for some reason we can't read the included logo we have a hard-coded fallback logo
	 * @return BufferedImage a 'gracefully degraded' DocShifter logo
	 */
	private static BufferedImage getFallbackLogo () {
		BufferedImage bufferedImage = null;
		// Logo data String has each byte represented as 2 hex digits
		// so the byte array size is 1/2 the length
		byte[] imageBytes = new byte[DS_LOGO_DATA.length()/2];
		for (int idx = 0;idx<DS_LOGO_DATA.length()/2;idx++) {
			// aByte is a 2-digit hex representation of one of the bytes
			String aByte = DS_LOGO_DATA.substring(idx*2, idx*2+2);
			// Radix 16 = we're parsing a hex number, not decimal
			imageBytes[idx] = (byte) Integer.parseInt(aByte, 16);
		}
		try (InputStream istr = new ByteArrayInputStream(imageBytes)) {
			bufferedImage = ImageIO.read(istr);
		}
		catch (IOException ioe) {
			log.warn("Could not read the logo from embedded data", ioe);
		}
		return bufferedImage;
	}
}
